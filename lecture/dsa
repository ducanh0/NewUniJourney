1 union find
  
  - quick find : a(i) = thành phần liên thông chứa i
      mỗi lần union phải chạy cả mảng để cập nhật
  -> chậm ở union

  - quick union : a(i) = tham chiếu trỏ tới nút gốc của cây chứa i
      khi union thì chỉ gần gán gốc cây này trỏ tới gốc cây kia
    -> chậm ở find

  - cải tiến : 
      + quick union có trọng số ( cho cây ít phần tử hơn làm con cây lớn hơn )
      
      + rút ngắn đường đi : sau khi đi từ nút x lên gốc cây của nó ( trong hàm find ) , ta đi lại đường đó một lần nữa để gán thẳng mỗi nút đó tới nút gốc luôn

  2 đánh giá thời gian chạy

  3 stack & queue

  - repeated doubling : khi cài đặt stack bằng mảng , khi mảng đầy thì nhân đôi độ dài mảng 
  - đợi mảng còn 1/4 thì mới giảm kích thước mảng đi 1/2

  - lập trình tổng quát
  - iterable : trả về 1 đối tượng iterator có các phương thức hasNext() , next(), remove() để duyệt các phần tử

  4 sort

  - call back : đại loại là truyền hàm customSort để hàm sort gọi tùy theo các loại dữ liệu

  - selection sort ( sắp xếp chọn ) : for N lần , ở lần lặp thứ i thì tìm phần tử nhỏ nhất còn lại rồi đổi chỗ với i , đại loại là mỗi lần lặp sẽ tìm thằng nhỏ nhất
để cho lên đầu

  - insertion sort ( sắp xếp chèn ) : for đến vị trí i thì sắp xếp luôn đoạn [ 1 ... i ] , hay nói cách khác là for đến i thì chèn i vào vị trí thích hợp luôn trong
dãy [ 1 ... i ] 

  - thuật toán tráo ngẫu nhiên knuth : for 1 -> N , ở vị trí i thì chọn j ngẫu nhiên trong [1, i) rồi đổi chỗ với i

  - merge sort : 
      + với các đoạn mảng nhỏ ( < 5 ) thì có thể dùng insertion sort để đỡ động đến mảng phụ ( sẽ dùng nếu là merge sort )
      + trước khi merge kiểm tra a(mid) <= a(mid + 1) có đúng không , có thì không cần merge

  - bottom up merge sort : for độ dài từ dưới lên ( 1 2 ... n ) để merge các đoạn đã sort vào

  - shell sort : chia mảng thành các mảng con cách nhau một khoảng h ([1 ,1 + h ,1 + 2h, ...] [2, 2 + h, 2 + 2h , ...], [3, 3 + h, 3 + 2h, ...] ...)
( sau đó sort các mảng con bằng insertion sort ) , sau đó giảm dần h và lặp lại như thế

  - quick sort : 
      +  với các đoạn mảng nhỏ ( < 5 ) thì có thể dùng insertion sort
      + mỗi lần lấy khóa thì lấy ra 1 tập nhỏ và lấy giá trị giữa trong nhóm đó
  - tìm phần tử nhỏ thứ k : 
      + khá giống quick sort , chọn 1 khóa và phân mảng thành 2 phần , bên trái không lớn hơn nó và bên phải không nhỏ hơn nó
      + tùy thuộc k lớn hơn hay nhỏ hơn vị trí khóa để tìm tiếp với nửa trái hay nửa phải

  - phân hoạch chia 3 : khi quicksort dùng 2 con trỏ để chia mảng làm 3 đoạn ( nhỏ hơn , bằng , lớn hơn khóa )
